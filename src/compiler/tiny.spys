section data
; C functions we will be using
let printf				"printf"	; void	printf(format, ...);
let malloc				"malloc"	; ptr	malloc(size);
let strcpy				"strcpy"	; void	strcpy(dest, src);

; ----- constant strings -----
let DEBUG_IO_INOUT		"input name: %s\noutput name: %s\n"

; printf formats
let FORMAT_SIMPLESTRING	"%s\n"
let FORMAT_SIMPLECHAR	"%c\n"
let FORMAT_SIMPLENUM	"%d\n"

; file system modes
let FS_MODE_W			"w"
let FS_MODE_R			"r"
let FS_MODE_WB			"wb"
let FS_MODE_RB			"rb"

; token information
; TYPE_IDENTIFIER		0x01
; TYPE_STRING			0x02
; TYPE_NUMBER			0x03
; TYPE_ADD				0x04
; TYPE_SUB				0x05
; TYPE_MUL				0x06
; TYPE_DIV				0x07
let TOK_DEBUG_OUT		"(type '%d' : word '%s')\n"

; registers
let REG_RIP				"RIP"
let REG_RSP				"RSP"
let REG_RBP				"RBP"
let REG_RAX				"RAX"
let REG_RBX				"RBX"
let REG_RCX				"RCX"
let REG_RDX				"RDX"
let REG_REX				"REX"
let REG_RFX				"RFX"
let REG_RGX				"RGX"
let REG_RHX				"RGX"
let REG_RIX				"RIX"
let REG_RJX				"RJX"


; CODE STARTS HERE
; some quick notes about the style of the code:
;	- a method of a 'class' has two underscores (__) before the name
;	- all 'class' methods take 'this' in as the first parameter
;	- for organizational purposes, arguments passed to a function are
;	  loaded onto the stack by the callee	
section code
jmp			start

; ARGS
;	REX: string TOKEN_TYPE
;	RFX: string TOKEN_WORD
; RET
;	returns a pointer to a Token
;	[RAX + 0] is TOKEN_TYPE
;	[RAX + 1] is TOKEN_WORD
__Token_new:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 2
	
	; this function creates a new token 
	; a token has two fields
	; [t + 0] = token typeof
	; [t + 1] = token word (sizeof 128) 
	
	mov		[rbp + 1], rex 
	mov		[rbp + 2], rfx
	
	; allocate some space for the token (two chunks)
	mov		rex, 129
	push	1
	ccall	malloc
	
	; the memory for the token is now stored in RAX
	; assign to the fields in memory accordingly
	; move the type in
	mov		[rax + 0], [rbp + 1]
	
	; move the word in
	mov		rex, rax
	add		rex, 1
	mov		rfx, [rbp + 2]
	push	rax
	push	2
	ccall	strcpy
	pop		rax

	mov		rax, rax
	mov		rsp, rbp
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: Token* t
__Token_print:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 1

	mov		[rbp + 1], rex

	; print the token information
	; load the format
	mov		rex, TOK_DEBUG_OUT
	; load the type
	mov		rfx, [rbp + 1]
	mov		rfx, [rfx + 0]
	; load the word
	mov		rgx, [rbp + 1]
	add		rgx, 1
	; now print
	push	3
	ccall	printf

	mov		rsp, rbp
	xor		rax, rax
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: number 
isalpha:
	push	rbp
	mov		rbp, rsp

	ge		rex, 97
	jif		C00
	le		rex, 122
	jif		C00
	mov		rax, 1
	jmp		C01
C00:
	mov		rax, 0
C01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: number
isdigit:
	push	rbp
	mov		rbp, rsp

	ge		rex, 48
	jif		D00
	le		rex, 57
	jif		D00
	mov		rax, 1
	jmp		D01
D00:
	mov		rax, 0
D01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: token array pointer
;	RFX: size of token array
printAllTokens:
	push	rbp
	mov		rbp, rsp
	add		rsp, 3

	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], 0
	
E00:
	lt		[rbp + 3], [rbp + 2]
	jif		E01
	
	; get a pointer to the current token in rax
	mov		rax, [rbp + 1]
	add		rax, [rbp + 3]

	; now print
	mov		rex, [rax + 0]
	call	__Token_print
	
	add		[rbp + 3], 1

	jmp		E00
E01:

	mov		rsp, rbp
	pop		rbp
	ret
	
; ARGUMENTS
; REX FILE CONTENTS
; RFX FILE CONTENTS LENGTH
; RGX FILE NAME
; RHX FILE OUTPUT NAME
start:
	
	mov		rbp, rsp	
	add		rsp, 2048
	; STACK MAP
	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	; FILE COUNTER				in [rbp + 5]
	; LOCAL CURRENT_CHAR		in [rbp + 6]
	; GENERAL PURPOSE NUMBS		in [rbp + [6, 50]]
	; GENERAL PURPOSE BUFFER	in [rbp + 51]  (of size 512)
	; TOKEN ARRAY POINTER		in [rbp + 562]
	; TOKEN ARRAY				in [rbp + 563] (of size 1024)

	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx
	mov		[rbp + 4], rhx	
	mov		[rbp + 562], 0
	
	; print some debugging information
	mov		rex, DEBUG_IO_INOUT
	mov		rfx, [rbp + 3]
	mov		rgx, [rbp + 4]
	push	3
	ccall	printf	

	; FILE COUNTER		in [rbp + 5]
	mov		[rbp + 5], 0

; while (FILE_COUNTER < FILE_CONTENTS_LENGTH)
L00:
	; FILE_COUNTER < FILE_CONTENTS_LENGTH
	mov		rbx, [rbp + 5]
	lt		rbx, [rbp + 2]
	jif		L01
	
	; load the current character into [rbp + 6]
	mov		rbx, [rbp + 1]			; [rbp + 1] is file contents pointer
	add		rbx, [rbp + 5]			; [rbp + 5] is current index in file contents
	mov		[rbp + 6], [rbx + 0]	; [rbp + 6] now contains the current character

	cmp		[rbp + 6], 32	; skip if is whitespace
	jit		L08
	cmp		[rbp + 6], 10	; skip if is newline
	jit		L08
	cmp		[rbp + 6], 9	; skip if is tab
	jit		L08

	; here is the start of the branching process
	; this is where we handle the difference between
	; an identifier, a string, a number, etc
	;	LABEL NOTES
	;		end of branch is L02
	;		
	; (c >= 'a' && c <= 'z');
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L09
	; decided true
	; note that there is a general purpose buffer located at [rbp + 51]
	; we will use that buffer to store the identifier
	mov		[rbp + 51], [rbp + 6]
	; note that we use the general purpose loca [rbp + 7] to store
	; the pointer to the top of the buffer at [rbp + 51]
	; also note we start with 1 because we already wrote the first character above
	mov		[rbp + 7], 1
L05: ; START IDENTIFIER LOOP
	add		[rbp + 5], 1			; increase FILE_COUNTER by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character (dereferenced rax)
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L06

	; we've made sure the character is alpha, now append it to the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]

	add		[rbp + 7], 1 ; increase the buffer pointer

	jmp		L05
L06: ; END IDENTIFIER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], 0

	mov		rex, 1
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02

L09: ; ELSE IF IS NUMBER
	; go to next if statement if its not a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L07

	; now we know it's a digit, proceed
	mov		[rbp + 51], [rbp + 6]	; move the first digit into the buffer
	
	; now, like before, we use the general purpose local [rbp + 7] to
	; store the pointer to the top of the buffer
	; we set its initial value to 1 because we already pushed the first number
	mov		[rbp + 7], 1
L10: ; START NUMBER LOOP
	; load the next character into [rbp + 6]
	add		[rbp + 5], 1			; increase file pointer by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character

	; now check again if it's a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L11
	
	; now we've made sure the next character is a digit, we can now append it to the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]
	
	; increase the buffer pointer
	add		[rbp + 7], 1	

	; do loop again
	jmp		L10

L11: ; END NUMBER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], 0

	; create a new token
	mov		rex, 3
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax

	; jump to the end of the if statement
	jmp		L02


L07: ; ELSE IF IS OPERATOR
	mov		[rbp + 51], [rbp + 6]
	mov		[rbp + 52], 0
	mov		rex, 2
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02

L02: ; LEX LOOP INCREMENT FILE_COUNTER

	; the token we created is in [rbp + 8]
	; append it to the token array
	mov		rax, rbp
	add		rax, 563
	add		rax, [rbp + 562]
	mov		[rax + 0], [rbp + 8]
	; now increase the token pointer
	add		[rbp + 562], 1

L08: ; JUMP HERE TO SKIP
	add		[rbp + 5], 1
	jmp		L00
L01: ; END LEX LOOP
	
	; print tokens for debugging
	mov		rex, rbp
	add		rex, 563
	mov		rfx, [rbp + 562]		
	call	printAllTokens

	exit

