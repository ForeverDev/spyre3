section data
; C functions we will be using
let printf				"printf"
let malloc				"malloc"
let free				"free"	
let strcpy				"strcpy"
let memcpy				"memcpy"
let memset				"memset"
let strcmp				"strcmp"
let fprintf				"fprintf"
let sprintf				"sprintf"
let fopen				"fopen"
let fclose				"fclose"

; ----- constant strings -----
let DEBUG_IO_INOUT		"input name: %s\noutput name: %s\n"

; printf formats
let FORMAT_STRING		"%s\n"
let FORMAT_CHAR			"%c\n"
let FORMAT_NUM			"%d\n"
let FORMAT_HEX			"%x\n"
let FORMAT_PTR			"%p\n"
let FORMAT_CPTR			"%t\n"

; file system modes
let FS_MODE_W			"w"
let FS_MODE_R			"r"
let FS_MODE_WB			"wb"
let FS_MODE_RB			"rb"

; token variables
let TOK_DEBUG_OUT		"(type %d : word '%s')\n"
let TOK_EOF				"EOF"

; tokenlist variables
let TOK_LIST_DEBUG_HEAD	"TOKENLIST:\n"
let TOK_KW_FUNC			"func"
let TOK_KW_IF			"if"
let TOK_KW_WHILE		"while"
let TOK_KW_DO			"do"
let TOK_KW_FOR			"for"
let TOK_KW_BREAK		"break"
let TOK_KW_CONTINUE		"continue"
let TOK_KW_RETURN		"return"
let TOK_KW_GOTO			"goto"
let TOK_KW_LABEL		"label"
let TOK_KW_LET			"let"
let TOK_KW_EXTERN		"extern"

; chunk variables
let	CHUNK_DEBUG			"CHUNK:\n\tTYPE: %d\n\tDEPTH: %d\n\tADDR: %p\n\tNEXT: %p\n\tLAST: %p\n"

; registers
let REG_RIP				"rip"
let REG_RSP				"rsp"
let REG_RBP				"rbp"
let REG_RAX				"rax"
let REG_RBX				"rbx"
let REG_RCX				"rcx"
let REG_RDX				"rdx"
let REG_REX				"rex"
let REG_RFX				"rfx"
let REG_RGX				"rgx"
let REG_RHX				"rgx"
let REG_RIX				"rix"
let REG_RJX				"rjx"

; instructions
let	INS_NOOP			"noop"
let INS_EXIT			"exit"
let INS_RET				"ret"
let INS_MOV				"mov"
let INS_ADD				"add"
let INS_SUB				"sub"	
let INS_MUL				"mul"
let INS_DIV				"div"
let INS_NEG				"neg"
let INS_OR				"or"
let INS_AND				"and"
let INS_XOR				"xor"
let INS_NOT				"not"
let INS_SHL				"shl"
let INS_SHR				"shr"
let INS_LT				"lt"
let INS_LE				"le"
let INS_GT				"gt"
let INS_GE				"ge"
let INS_CMP				"cmp"
let INS_LAND			"land"
let INS_LOR				"lor"
let INS_LNOT			"lnot"
let INS_PUSH			"push"
let INS_POP				"pop"
let INS_CALL			"call"
let INS_CCALL			"ccall"
let INS_JMP				"jmp"
let INS_JIF				"jif"
let INS_JIT				"jit"

let PUT_MODE0			"%s\t\n"
let PUT_MODE1			"%s\t%s\n" 
let PUT_MODE2			"%s\t%s, %d\n"
let PUT_MODE3			"%s\t%s, %s\n"
let PUT_MODE4			"%s\t%s, [%s + %d]\n"
let PUT_MODE5			"%s\t[%s + %d], %d\n"
let PUT_MODE6			"%s\t[%s + %d]\n"
let PUT_MODE7			"%s\t%d\n"
let PUT_MODE7S			"%s\t%s\n"
let PUT_MODE8			"%s\t[%s + %d], [%s + %d]\n"
let PUT_LABEL			"%s:\n"
let PUT_SECT			"section %s"
let PUT_LET				"let \"%s\"\n"

let SECT_DATA			"data"
let SECT_CODE			"code"
let LBL_START			"start"

; --------------- START LEXER ---------------
section code
jmp			start

; ARGS
;	REX: string TOKEN_TYPE
;	RFX: string TOKEN_WORD
; RET
;	returns a pointer to a Token
;	[RAX + 0] is TOKEN_TYPE
;	[RAX + 1] is TOKEN_WORD
__Token_new:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 2
	
	; this function creates a new token 
	; a token has two fields
	; [t + 0] = token typeof
	; [t + 1] = token word (sizeof 128) 
	
	mov		[rbp + 1], rex 
	mov		[rbp + 2], rfx
	
	; allocate some space for the token (two chunks)
	mov		rex, 129
	push	1
	ccall	malloc
	
	; the memory for the token is now stored in RAX
	; assign to the fields in memory accordingly
	; move the type in
	mov		[rax + 0], [rbp + 1]
	
	; move the word in
	lea		rex, [rax + 1]
	mov		rfx, [rbp + 2]
	push	rax
	push	2
	ccall	strcpy
	pop		rax

	mov		rax, rax
	mov		rsp, rbp
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: Token* t
__Token_print:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 1

	mov		[rbp + 1], rex

	; print the token information
	; load the format
	mov		rex, TOK_DEBUG_OUT
	; load the type
	mov		rfx, [rbp + 1]
	mov		rfx, [rfx + 0]
	; load the word
	mov		rgx, [rbp + 1]
	add		rgx, 1
	; now print
	push	3
	ccall	printf

	mov		rsp, rbp
	xor		rax, rax
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: number 
isalpha:
	push	rbp
	mov		rbp, rsp
	
	; c >= 97 && c <= 122
	ge		rex, 97
	jif		C00
	le		rex, 122
	jif		C00
	mov		rax, 1
	jmp		C01
C00:
	; || c == '_'
	cmp		rex, 95
	jif		C02
	mov		rax, 1
	jmp		C01
C02:
	mov		rax, 0
C01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: number
isdigit:
	push	rbp
	mov		rbp, rsp

	ge		rex, 48
	jif		D00
	le		rex, 57
	jif		D00
	mov		rax, 1
	jmp		D01
D00:
	mov		rax, 0
D01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: token array pointer
;	RFX: size of token array
printAllTokens:
	push	rbp
	mov		rbp, rsp
	add		rsp, 3

	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], 0
	
E00:
	lt		[rbp + 3], [rbp + 2]
	jif		E01
	
	; get a pointer to the current token in rax
	mov		rax, [rbp + 1]
	add		rax, [rbp + 3]

	; now print
	mov		rex, [rax + 0]
	call	__Token_print
	
	add		[rbp + 3], 1

	jmp		E00
E01:

	mov		rsp, rbp
	pop		rbp
	ret
	
generateTokens:
	
	push	rbp
	mov		rbp, rsp	
	add		rsp, 2048
	; STACK MAP
	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	; FILE COUNTER				in [rbp + 5]
	; LOCAL CURRENT_CHAR		in [rbp + 6]
	; GENERAL PURPOSE NUMBS		in [rbp + [6, 50]]
	; GENERAL PURPOSE BUFFER	in [rbp + 51]  (of size 512)
	; TOKEN ARRAY POINTER		in [rbp + 562]
	; TOKEN ARRAY				in [rbp + 563] (of size 1024)

	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx
	mov		[rbp + 4], rhx	
	mov		[rbp + 562], 0
	
	; print some debugging information
	mov		rex, DEBUG_IO_INOUT
	mov		rfx, [rbp + 3]
	mov		rgx, [rbp + 4]
	push	3
	ccall	printf	

	; FILE COUNTER		in [rbp + 5]
	mov		[rbp + 5], 0

; while (FILE_COUNTER < FILE_CONTENTS_LENGTH)
L00:
	; FILE_COUNTER < FILE_CONTENTS_LENGTH
	mov		rbx, [rbp + 5]
	lt		rbx, [rbp + 2]
	jif		L01
	
	; load the current character into [rbp + 6]
	mov		rbx, [rbp + 1]			; [rbp + 1] is file contents pointer
	add		rbx, [rbp + 5]			; [rbp + 5] is current index in file contents
	mov		[rbp + 6], [rbx + 0]	; [rbp + 6] now contains the current character

	cmp		[rbp + 6], 32	; skip if is whitespace
	jit		L08
	cmp		[rbp + 6], 9	; skip if is tab
	jit		L08

	; here is the start of the branching process
	; this is where we handle the difference between
	; an identifier, a string, a number, etc
	;	LABEL NOTES
	;		end of branch is L02
	;		
	; (c >= 'a' && c <= 'z');
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L09
	; decided true
	; note that there is a general purpose buffer located at [rbp + 51]
	; we will use that buffer to store the identifier
	mov		[rbp + 51], [rbp + 6]
	; note that we use the general purpose loca [rbp + 7] to store
	; the pointer to the top of the buffer at [rbp + 51]
	; also note we start with 1 because we already wrote the first character above
	mov		[rbp + 7], 1
L05: ; START IDENTIFIER LOOP
	add		[rbp + 5], 1			; increase FILE_COUNTER by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character (dereferenced rax)
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L06

	; we've made sure the character is alpha, now append it to the buffer
	lea		rax, [rbp + 51]
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]

	add		[rbp + 7], 1 ; increase the buffer pointer

	jmp		L05
L06: ; END IDENTIFIER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	lea		rax, [rbp + 51]
	add		rax, [rbp + 7]
	mov		[rax + 0], 0
	
	lea		rex, [rbp + 51]	
	mov		rfx, TOK_KW_FUNC		; check 'func'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_01
	mov		[rbp + 9], 101
	jmp		L06_00
L06_01:	
	mov		rfx, TOK_KW_IF			; check 'if'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_02
	mov		[rbp + 9], 102
	jmp		L06_00
L06_02:	
	mov		rfx, TOK_KW_WHILE		; check 'while'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_03
	mov		[rbp + 9], 103
	jmp		L06_00
L06_03:
	mov		rfx, TOK_KW_DO			; check 'while'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_04
	mov		[rbp + 9], 104
	jmp		L06_00
L06_04:
	mov		rfx, TOK_KW_FOR			; check 'for'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_05
	mov		[rbp + 9], 105
	jmp		L06_00
L06_05:
	mov		rfx, TOK_KW_BREAK		; check 'break'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_06
	mov		[rbp + 9], 106
	jmp		L06_00
L06_06:
	mov		rfx, TOK_KW_CONTINUE	; check 'continue'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_07
	mov		[rbp + 9], 107
	jmp		L06_00
L06_07:
	mov		rfx, TOK_KW_RETURN		; check 'continue'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_08
	mov		[rbp + 9], 108
	jmp		L06_00
L06_08:
	mov		rfx, TOK_KW_GOTO		; check 'goto'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_09
	mov		[rbp + 9], 109
	jmp		L06_00
L06_09:
	mov		rfx, TOK_KW_LABEL		; check 'label'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_10
	mov		[rbp + 9], 110
	jmp		L06_00
L06_10:
	mov		rfx, TOK_KW_EXTERN		; check 'extern'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_11
	mov		[rbp + 9], 111
	jmp		L06_00
L06_11:
	mov		rfx, TOK_KW_LET			; check 'let'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_else
	mov		[rbp + 9], 112
	jmp		L06_00
L06_else:
	mov		[rbp + 9], 1
L06_00:
	mov		rex, [rbp + 9]
	lea		rfx, [rbp + 51]
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02 

L09: ; ELSE IF IS NUMBER
	; go to next if statement if its not a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L07

	; now we know it's a digit, proceed
	mov		[rbp + 51], [rbp + 6]	; move the first digit into the buffer
	
	; now, like before, we use the general purpose local [rbp + 7] to
	; store the pointer to the top of the buffer
	; we set its initial value to 1 because we already pushed the first number
	mov		[rbp + 7], 1
L10: ; START NUMBER LOOP
	; load the next character into [rbp + 6]
	add		[rbp + 5], 1			; increase file pointer by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character

	; now check again if it's a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L11
	
	; now we've made sure the next character is a digit, we can now append it to the buffer
	lea		rax, [rbp + 51]
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]
	
	; increase the buffer pointer
	add		[rbp + 7], 1	

	; do loop again
	jmp		L10

L11: ; END NUMBER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	lea		rax, [rbp + 51]
	add		rax, [rbp + 7]
	mov		[rax + 0], 0

	; create a new token
	mov		rex, 3
	lea		rfx, [rbp + 51]
	call	__Token_new
	mov		[rbp + 8], rax

	; jump to the end of the if statement
	jmp		L02


L07: ; ELSE IF IS OPERATOR
	; now we know that the character is some sort of punctuation or operator
	; we need to set the type of the token accordingly

	; note we store the correct type for the token in the
	; general purpose offset [rbp + 9]
	mov		[rbp + 51], [rbp + 6]
	mov		[rbp + 52], 0 ; initialize the type to TYPE_UNKNOWN
	mov		[rbp + 9], 0
	; switch(character)
	cmp		[rbp + 6], 43 ; case +
	jif		L13
	mov		[rbp + 9], 4
	jmp		L12
L13:
	cmp		[rbp + 6], 45 ; case -
	jif		L14
	mov		[rbp + 9], 5
	jmp		L12
L14:
	cmp		[rbp + 6], 42 ; case *
	jif		L15
	mov		[rbp + 9], 6
	jmp		L12
L15:
	cmp		[rbp + 6], 47 ; case /
	jif		L16
	mov		[rbp + 9], 7
	jmp		L12
L16:
	cmp		[rbp + 6], 37 ; case %
	jif		L17
	mov		[rbp + 9], 8
	jmp		L12
L17:
	cmp		[rbp + 6], 38 ; case &
	jif		L18
	mov		[rbp + 9], 9
	jmp		L12
L18:
	cmp		[rbp + 6], 124 ; case |
	jif		L19
	mov		[rbp + 9], 10
	jmp		L12
L19:
	cmp		[rbp + 6], 94 ; case ^
	jif		L20
	mov		[rbp + 9], 11
	jmp		L12
L20:
	cmp		[rbp + 6], 59 ; case ;
	jif		L21
	mov		[rbp + 9], 12
	jmp		L12
L21:
	cmp		[rbp + 6], 58 ; case :
	jif		L22
	; check if :=
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L21_
	; is :=, rewrite word
	mov		[rbp + 52], 61 
	mov		[rbp + 53], 0
	mov		[rbp + 9], 28
	add		[rbp + 5], 1
	jmp		L12
L21_:
	mov		[rbp + 9], 13
	jmp		L12
L22:
	cmp		[rbp + 6], 40 ; case (
	jif		L23
	mov		[rbp + 9], 14
	jmp		L12
L23:
	cmp		[rbp + 6], 41 ; case )
	jif		L24
	mov		[rbp + 9], 15
	jmp		L12
L24:
	cmp		[rbp + 6], 123 ; case {
	jif		L25
	mov		[rbp + 9], 16
	jmp		L12
L25:
	cmp		[rbp + 6], 125 ; case }
	jif		L26
	mov		[rbp + 9], 17
	jmp		L12
L26:
	cmp		[rbp + 6], 91 ; case [
	jif		L27
	mov		[rbp + 9], 18
	jmp		L12
L27:
	cmp		[rbp + 6], 93 ; case ]
	jif		L28
	mov		[rbp + 9], 19
	jmp		L12
L28:
	cmp		[rbp + 6], 60 ; case <
	jif		L29
	; check if <=
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L28_
	; is <=, rewrite word
	mov		[rbp + 52], 61 
	mov		[rbp + 53], 0
	mov		[rbp + 9], 25
	add		[rbp + 5], 1
	jmp		L12
L28_:
	mov		[rbp + 9], 20
	jmp		L12
L29:
	cmp		[rbp + 6], 62 ; case >
	jif		L30
	; check if >=
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L29_
	; is >=, rewrite word
	mov		[rbp + 52], 61
	mov		[rbp + 53], 0
	mov		[rbp + 9], 26
	add		[rbp + 5], 1
	jmp		L12
L29_:
	mov		[rbp + 9], 21
	jmp		L12
L30:
	cmp		[rbp + 6], 61 ; case =
	jif		L31
	; check if ==
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L30_
	; is ==, rewrite word
	mov		[rbp + 52], 61
	mov		[rbp + 53], 0
	mov		[rbp + 9], 27
	add		[rbp + 5], 1
	jmp		L12
L30_:
	mov		[rbp + 9], 22
	jmp		L12
L31:
	cmp		[rbp + 6], 44 ; case ,
	jif		L32
	mov		[rbp + 9], 23
	jmp		L12
L32:
	cmp		[rbp + 6], 46 ; case .
	jif		L33
	mov		[rbp + 9], 24
	jmp		L12
L33:
	cmp		[rbp + 6], 10 ; case \n
	jif		L34
	; because it's a newline we don't actually want the
	; word of the token to be '\n' (for debugging reasons)
	; here we just overwrite the word
	mov		[rbp + 51], 0
	mov		[rbp + 9], 25
	jmp		L12
L34:
L12:
	mov		rex, [rbp + 9]
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02

L02: ; LEX LOOP INCREMENT FILE_COUNTER
	; the token we created is in [rbp + 8]
	; append it to the token array
	lea		rax, [rbp + 563]
	add		rax, [rbp + 562]
	mov		[rax + 0], [rbp + 8]
	; now increase the token pointer
	add		[rbp + 562], 1

	mov		rex, [rbp + 8]

L08: ; JUMP HERE TO SKIP
	add		[rbp + 5], 1
	jmp		L00
L01: ; END LEX LOOP
	; add a null token
	mov		rex, 0
	mov		rfx, TOK_EOF
	call	__Token_new
	mov		[rbp + 8], rax
	lea		rax, [rbp + 563]
	add		rax, [rbp + 562]
	mov		[rax + 0], [rbp + 8]
	add		[rbp + 562], 1

	; return a pointer to the tokens
	lea		rax, [rbp + 563]
	
	mov		rsp, rbp
	pop		rbp	
	ret

; --------------- START PARSER ---------------

; ARGS
;	REX token
__TokenList_new:
	push	rbp
	mov		rbp, rsp
	add		rsp, 1

	mov		[rbp + 1], rex
	
	; allocate memory for the list
	mov		rex, 2
	push	1
	ccall	malloc

	mov		[rax + 0], [rbp + 1]
	; also write a null pointer for the `next` field because
	; there is no next token yet
	mov		[rax + 1], 0

	mov		rax, rax

	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: TokenList
__TokenList_getTail:
	push	rbp
	mov		rbp, rsp
	add		rsp, 2

	; [rbp + 1] is TokenList
	mov		[rbp + 1], rex

getTail00:
	; while (t->next != NULL)
	mov		rax, [rbp + 1]
	cmp		[rax + 1], 0
	jit		getTail01

	; t = t->next;
	mov		rax, [rbp + 1]
	mov		[rbp + 1], [rax + 1]

	jmp		getTail00
getTail01:
	mov		rax, [rbp + 1]
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: TokenList head
;	RFX: TokenList to append
__TokenList_append:
	push	rbp
	push	rbx
	mov		rbp, rsp
	add		rsp, 2
	
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	
	; if head->value is NULL, then just set
	; head to the new token, don't append
	mov		rax, [rbp + 1]
	cmp		[rax + 0], 0
	jif		append01
append00:
	; head->next remains NULL
	; head->value becomes to_append->value
	mov		rax, [rbp + 1]
	mov		rbx, [rbp + 2]
	mov		[rax + 0], [rbx + 0]
	mov		[rax + 1], 0
	mov		[rbx + 1], 0
	jmp		append02
append01:
	; set to_append->next to null
	mov		rax, [rbp + 2]
	mov		[rax + 1], 0

	; get the tail of the TokenList to append to
	mov		rex, [rbp + 1]
	call	__TokenList_getTail
	; now set TokenList->tail->next to the TokenList we just created
	mov		[rax + 1], [rbp + 2]
append02:
	mov		rsp, rbp
	pop		rbx
	pop		rbp
	ret

; ARGS
;	REX: TokenList
__TokenList_print:
	push	rbp
	mov		rbp, rsp
	add		rsp, 3
	
	; [rbp + 1] TokenList
	; [rbp + 2] TokenList->tail
	mov		[rbp + 1], rex
	
	; printf("TOKENLIST:\n");
	mov		rex, TOK_LIST_DEBUG_HEAD
	push	1
	ccall	printf

	mov		[rbp + 3], [rbp + 1]
print00:
	; while (t != NULL)
	cmp		[rbp + 3], 0
	jit		print01

	; if there is no token being pointed to
	; then continue
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 0
	jit		print02

	mov		rex, [rbp + 3]
	mov		rex, [rex + 0]
	call	__Token_print

	; t = t->next
print02:
	mov		rax, [rbp + 3]
	mov		[rbp + 3], [rax + 1]

	jmp		print00
print01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: type
;	RFX: relation
;	RGX: pointer to last
__Chunk_new:
	push	rbp
	push	rbx
	mov		rbp, rsp
	add		rsp, 5

	; [rbp + 1] type
	; [rbp + 2] relation
	; [rbp + 3] pointer to last
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx

	; allocate some memory for a chunk
	mov		rex, 8
	push	1
	ccall	malloc
	mov		[rbp + 4], rax ; [rbp + 4] chunk

	mov		rax, [rbp + 4]
	mov		[rax + 0], [rbp + 1]	; set chunk->type
	mov		[rax + 1], [rbp + 2]	; set chunk->relation
	mov		[rax + 2], 0			; set chunk->next	
	mov		[rax + 3], [rbp + 3]	; set chubk->last

	; initialize general lists to NULL
	; [rbp + 5] is loop counter
	mov		[rbp + 5], 0
Chunknew00:
	lt		[rbp + 5], 4
	jif		Chunknew01
	
	; create a new general list
	mov		rex, 0
	call	__TokenList_new

	; move it into the proper field
	mov		rbx, [rbp + 4]
	add		rbx, 4
	add		rbx, [rbp + 5]
	mov		[rbx + 0], rax

	add		[rbp + 5], 1
	jmp		Chunknew00
Chunknew01:	
	mov		rax, [rbp + 4]
	mov		rsp, rbp
	pop		rbx
	pop		rbp
	ret

; ARGS
;	REX: chunk
__Chunk_getTail:
	push	rbp
	mov		rbp, rsp
	add		rsp, 1
	
	; this is the current chunk we're at
	mov		[rbp + 1], rex	
Chunk_getTail00:
	; check if chunk->next is NULL
	mov		rax, [rbp + 1]
	cmp		[rax + 2], 0
	jit		Chunk_getTail01

	mov		rax, [rbp + 1]
	mov		[rbp + 1], [rax + 2]

	jmp		Chunk_getTail00
Chunk_getTail01:
	; return the tail
	mov		rax, [rbp + 1]
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: chunk
;	RFX: chunk to append
__Chunk_append:
	push	rbp
	mov		rbp, rsp
	add		rsp, 2
	
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx

	; get the tail of the chunk we want to append to
	mov		rex, [rbp + 1]
	call	__Chunk_getTail
	
	; set tail->next to chunk_to_append
	mov		[rax + 2], [rbp + 2]

	; make sure to set chunk_to_append->next to NULL
	mov		rax, [rbp + 2]
	mov		[rax + 2], 0

	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: chunk
__Chunk_print:
	push	rbp
	mov		rbp, rsp
	add		rsp, 1

	; pointer to the current chunk	
	mov		[rbp + 1], rex
Chunk_print00:
	cmp		[rbp + 1], 0
	jit		Chunk_print01

	mov		rex, CHUNK_DEBUG
	mov		rfx, [rbp + 1]
	mov		rfx, [rfx + 0]
	mov		rgx, [rbp + 1]
	mov		rgx, [rgx + 1]
	mov		rhx, [rbp + 1]
	mov		rix, [rbp + 1]
	mov		rix, [rix + 2]
	mov		rjx, [rbp + 1]
	mov		rjx, [rjx + 3]
	push	6
	ccall	printf
	
	mov		rax, [rbp + 1]
	mov		rax, [rax + 4]
	cmp		[rax + 0], 0
	jit		Chunk_print02
	mov		rex, [rbp + 1]
	mov		rex, [rex + 4]
	call	__TokenList_print
Chunk_print02:
	mov		rax, [rbp + 1]
	mov		rax, [rax + 5]
	cmp		[rax + 0], 0
	jit		Chunk_print03
	mov		rex, [rbp + 1]
	mov		rex, [rex + 5]
	call	__TokenList_print
Chunk_print03:
	mov		rax, [rbp + 1]
	mov		rax, [rax + 6]
	cmp		[rax + 0], 0
	jit		Chunk_print04
	mov		rex, [rbp + 1]
	mov		rex, [rex + 6]
	call	__TokenList_print
Chunk_print04:
	mov		rax, [rbp + 1]
	mov		rax, [rax + 7]
	cmp		[rax + 0], 0
	jit		Chunk_print05
	mov		rex, [rbp + 1]
	mov		rex, [rex + 7]
	call	__TokenList_print
Chunk_print05:
	mov		rex, FORMAT_CHAR
	mov		rfx, 10
	push	1
	ccall	printf

	mov		rax, [rbp + 1]
	mov		[rbp + 1], [rax + 2]
	jmp		Chunk_print00
Chunk_print01:
	
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: TokenList to reorganize
__Chunk_convertToPostfix:
	ret

; ARGS
;	REX: chunk
;	RFX: index
;	RGX: token_list
;	RHX: should_convert_to_postfix
__Chunk_setGeneralField:
	push	rbp
	mov		rbp, rsp
	sub		rsp,

	mov		[rbp + 1], rex ; chunk
	mov		[rbp + 2], rfx ; index
	mov		[rbp + 3], rgx ; token_list

	; find the location we want to write to
	mov		rax, [rbp + 1]
	add		rax, 4
	add		rax, [rbp + 2]

	; TODO this is where we will implement conversion
	; to postfix.  only convert to postfix if RHX is 1
	
	; now write
	jif		setGF00
	lea		rex, [rbp + 3]
	push	rax
	call	__Chunk_convertToPostfix
	pop		rax
setGF00:
	mov		[rax + 0], [rbp + 3]

	mov		rsp, rbp
	pop		rbp
	ret	

; ARGS
;	REX: array of tokens
;	RFX: POINTER to current index (so that we can increment it as we go)
;	RGX: incrementer
;	RHX: decrementer
; RETURNS
;	a new token list containing the tokens up to and NOT 
;	including the token type specified in RGX
parseUntil:
	push	rbp
	push	rbx
	mov		rbp, rsp
	add		rsp, 7
	
	; load arguments	
	mov		[rbp + 1], rex	; array of tokens
	mov		[rbp + 2], rfx	; current index of token (IS A POINTER)
	mov		[rbp + 3], rgx	; incrementer
	mov		[rbp + 4], rhx	; decrementer

	; create a new TokenList, this what we will append
	; to and what we will return
	mov		rex, 0
	call	__TokenList_new
	mov		[rbp + 5], rax

	; this is the counter that tells us when to exit the loop
	mov		[rbp + 6], 1

parseUntil00:
	; get the index
	mov		rax, [rbp + 2]
	mov		rax, [rax + 0]

	; get the type of token, save in [rbp + 7]
	mov		rbx, [rbp + 1]
	add		rbx, rax
	mov		rbx, [rbx + 0]
	mov		[rbp + 7], [rbx + 0]

	; check incrementer
	cmp		[rbp + 3], 0
	jit		parseUntil02

	cmp		[rbp + 7], [rbp + 3]
	jif		parseUntil02
	add		[rbp + 6], 1
	jmp		parseUntil03
parseUntil02:
	; check decrementer
	cmp		[rbp + 7], [rbp + 4]
	jif		parseUntil03
	sub		[rbp + 6], 1
parseUntil03:

	cmp		[rbp + 6], 0
	jit		parseUntil01	
	; create a TokenList to append to the main once
	mov		rex, [rbp + 1]
	mov		rax, [rbp + 2]
	add		rex, [rax + 0]
	mov		rex, [rex + 0]
	call	__TokenList_new
	mov		rex, [rbp + 5]
	mov		rfx, rax
	call	__TokenList_append
	
	mov		rax, [rbp + 2]
	add		[rax + 0], 1
	
	jmp		parseUntil00
parseUntil01:	
	mov		rax, [rbp + 5]

	mov		rsp, rbp
	pop		rbx
	pop		rbp
	ret

; ARGS
;	REX: array of tokens
generateTree:
	push	rbp
	mov		rbp, rsp
	add		rsp, 80 ; [50, 80] general purpose

	; [rbp + 1]		array of tokens
	; [rbp + 2]		index of current token
	; [rbp + 3]		holds the current token
	; [rbp + 4]		head chunk for syntax tree
	; [rbp + 5]		current syntax tree depth
	; [rbp + 6]		the chunk we will append to the main sytax tree
	; [rbp + 7]		general0
	; [rbp + 8]		general1
	; [rbp + 9]		general2
	; [rbp + 10]	last chunk

	mov		[rbp + 1], rex
	mov		[rbp + 2], 0
	mov		[rbp + 3], 0
	
	; create a head chunk for the syntax tree
	; move it into [rbp + 4]
	mov		rex, 1
	mov		rfx, 0
	mov		rgx, 0
	call	__Chunk_new
	mov		[rbp + 4], rax
	
	; also move the chunk into [rbp + 10]
	mov		[rbp + 10], rax

	; the current tree depth, stored in [rbp + 5]
	mov		[rbp + 5], 0

genT00: ; while tokens[i].type != TYPE_UNKNOWN
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	cmp		[rax + 0], 0
	jit		genT01

	; store current token
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0] 

	; the new chunk we want to append will be stored
	; in [rbp + 6]

	; switch (token->type)
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 25
	jit		genT04				; skip if newline
	
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 17		; skip and decrement depth if '}'
	jif		genT00_99
	sub		[rbp + 5], 1
	jmp		genT04
genT00_99:
	
	; --- CHECK FUNC TOKEN ---
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 101
	jif		genT03	
		
	; --- IS FUNC ---
	; SYNTAX FOR A FUNCTION IMPLEMENTATION:
	; func name(argnamee, argname2, ...) { ... }

	; create a chunk to hold the function
	mov		rex, 3
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax
	
	; function name TokenList 
	mov		rex, 0
	call	__TokenList_new
	mov		[rbp + 7], rax

	; function arguments TokenList
	mov		rex, 0
	call	__TokenList_new
	mov		[rbp + 8], rax

	; increment the token pointer to the name of the function
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; store the TokenList containing the name in chunk->general[0]
	mov		rex, [rbp + 3]
	call	__TokenList_new
	mov		rex, [rbp + 7]
	mov		rfx, rax
	call	__TokenList_append
	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, [rbp + 7]
	mov		rhx, 0
	call	__Chunk_setGeneralField

	; increment the token pointer to the first argument
	; note that we increment by two to skip over the '('
	add		[rbp + 2], 2
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]
genT00_00: ; while (token != ')') (gather all arguments)
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 15
	jit		genT00_01

	; append the argument to general[2]
	mov		rex, [rbp + 3]
	call	__TokenList_new
	mov		rex, [rbp + 8]
	mov		rfx, rax
	call	__TokenList_append
	
	; increment pointer by 1
	; if it's a comma, skip and jump back up to the loop
	; else jump to end
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	mov		rax, [rbp + 3]
	cmp		[rax + 0], 23
	jif		genT00_01
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]
	jmp		genT00_00
genT00_01:
	
	; store the arguments list
	mov		rex, [rbp + 6]
	mov		rfx, 1
	mov		rgx, [rbp + 8]
	call	__Chunk_setGeneralField

	; we're currently on the closing ')' of the function arguments list
	; increment by two to land on the first token in the function
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]
	
	; also increment the depth counter by once because we're going into a function
	add		[rbp + 5], 1

	jmp		genT02
	; --- END OF 'FUNC' PARSING ---
	; --- ELSE IF 'IF' ---
genT03:
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 102
	jif		genT06	
	
	mov		rex, 4
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax
	
	; we're currently on the token 'if'
	; move ahead one so that we land on the
	; first token of the condition
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; increase the depth counter
	add		[rbp + 5], 1
	
	; parse the entire condition, stopping on the '{'
	mov		rex, [rbp + 1]
	lea		rfx, [rbp + 2]
	mov		rgx, 0
	mov		rhx, 16
	call	parseUntil
	
	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 1
	call	__Chunk_setGeneralField

	; move the token pointer up one more, getting infront of the '{'
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	; --- END OF 'IF' PARSING ---
	; --- ELSE IF 'WHILE' ---
genT06: 
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 103
	jif		genT05	
	
	mov		rex, 5
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax
	
	; we're currently on the token 'while'
	; move ahead one so that we land on the
	; first token of the condition
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; increase the depth counter
	add		[rbp + 5], 1
	
	; parse the entire condition, stopping on the '{'
	mov		rex, [rbp + 1]
	lea		rfx, [rbp + 2]
	mov		rgx, 0
	mov		rhx, 16
	call	parseUntil
	
	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 1
	call	__Chunk_setGeneralField

	; move the token pointer up one more, getting infront of the '{'
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	; --- END OF 'WHILE' PARSING ---
genT05:
	; --- ELSE IF 'FOR'

	mov		rax, [rbp + 3]
	cmp		[rax + 0], 105
	jif		genT07
	
	; create the chunk to append
	mov		rex, 6
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'FOR'
	; increment by one so that we are on
	; the first token of the initialization
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; increase the depth counter
	add		[rbp + 5], 1

	; parse the initialization until a ';'
	mov		rex, [rbp + 1]
	lea		rfx, [rbp + 2]
	mov		rgx, 0
	mov		rhx, 12
	call	parseUntil

	; now set general[0]
	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 1
	call	__Chunk_setGeneralField

	; we're on the semicolon of the initialization
	; increment by one to get past it
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; we're on the first token of the condition
	mov		rex, [rbp + 1]
	lea		rfx, [rbp + 2]
	mov		rgx, 0
	mov		rhx, 12
	call	parseUntil

	; now set general[1]
	mov		rex, [rbp + 6]
	mov		rfx, 1
	mov		rgx, rax
	mov		rhx, 1
	call	__Chunk_setGeneralField

	; we're on the semicolon of the coniditon
	; increment by one to get past it
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; we're at the start of the statement
	mov		rex, [rbp + 1]
	lea		rfx, [rbp + 2]
	mov		rgx, 0
	mov		rhx, 16
	call	parseUntil

	; now set general[2]
	mov		rex, [rbp + 6]
	mov		rfx, 2
	mov		rgx, rax
	mov		rhx, 1
	call	__Chunk_setGeneralField

	; we're on the '{' increment by one to pass it
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	
	; --- END OF FOR PARSING ---
	; --- ELSE IF 'RETURN' ---
genT07:
	
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 108
	jif		genT08

	mov		rex, 7
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'RETURN'
	; increment by one so that we are on
	; the first token of the statement
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; parse the statement until a ';'
	mov		rex, [rbp + 1]
	lea		rfx, [rbp + 2]
	mov		rgx, 0
	mov		rhx, 12
	call	parseUntil

	; now set general[0]
	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 0
	call	__Chunk_setGeneralField
	
	jmp		genT02
	
	; --- END OF RETURN PARSING ---
	; --- ELSE IF 'CONTINUE' ---
genT08:
	
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 107
	jif		genT09

	mov		rex, 8
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'CONTINUE'
	; increment to skip over the semicolon
	add		[rbp + 2], 2
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	; --- END CONTINUE PARSING ---
	; --- ELSE IF BREAK ---
genT09:
	
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 106
	jif		genT10

	mov		rex, 9
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'BREAK'
	; increment to skip over the semicolon
	add		[rbp + 2], 2
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	
	; --- END BREAK PARSING ---
	; --- ELSE IF GOTO ---
genT10:
	
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 109
	jif		genT11

	mov		rex, 10
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'GOTO'
	; increment and assign the identifier
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; now we're on the identifier
	mov		rex, [rbp + 3]
	call	__TokenList_new

	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 0
	call	__Chunk_setGeneralField

	; still on the identifier, increment
	; to skip over the semicolon
	add		[rbp + 2], 2
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	
	; --- END OF 'GOTO' PARSING ---
	; --- ELSE IF LABEL ---
genT11:
	
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 110
	jif		genT12

	mov		rex, 11
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'LABEL'
	; increment and assign the identifier
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; now we're on the identifier
	mov		rex, [rbp + 3]
	call	__TokenList_new

	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 0
	call	__Chunk_setGeneralField

	; still on the identifier, increment
	; to skip over the semicolon
	add		[rbp + 2], 2
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	; --- END LABEL PARSING ---
	; --- ELSE IF EXTERN --- 

genT12:

	mov		rax, [rbp + 3]
	cmp		[rax + 0], 111
	jif		genT13

	mov		rex, 12
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'EXTERN'
	; increment and assign the identifier
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; now we're on the identifier
	mov		rex, [rbp + 3]
	call	__TokenList_new

	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 0
	call	__Chunk_setGeneralField

	; still on the identifier, increment
	; to skip over the semicolon
	add		[rbp + 2], 2
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	
	; --- END EXTERN PARSING ---
	; --- ELSE IF LET ---

genT13:

	mov		rax, [rbp + 3]
	cmp		[rax + 0], 112
	jif		genT14

	mov		rex, 13
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the token 'EXTERN'
	; increment and assign the identifier
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; now we're on the identifier
	mov		rex, [rbp + 3]
	call	__TokenList_new

	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 0
	call	__Chunk_setGeneralField

	; still on the identifier, increment
	; to skip over the semicolon
	add		[rbp + 2], 2
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02

	; --- END LET PARSING ---
	; --- ELSE ---

genT14:
	
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 0
	jit		genT04			; skip if EOF

	; no special structure here, it is just an expression
	; simple parse to the nearest semicolon
	mov		rex, 99
	mov		rfx, [rbp + 5]
	mov		rgx, [rbp + 10]
	call	__Chunk_new
	mov		[rbp + 6], rax

	; we're on the start of the expression, 
	; parse the statement until a ';'
	mov		rex, [rbp + 1]
	lea		rfx, [rbp + 2]
	mov		rgx, 0
	mov		rhx, 12
	call	parseUntil

	; now set general[0]
	mov		rex, [rbp + 6]
	mov		rfx, 0
	mov		rgx, rax
	mov		rhx, 0
	call	__Chunk_setGeneralField

	; increment over the semicolon
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
genT02: ; done, append to head chunk
	mov		rex, [rbp + 4]
	mov		rfx, [rbp + 6]
	call	__Chunk_append
	mov		[rbp + 10], [rbp + 6]
genT04: ; skip, don't append
	add		[rbp + 2], 1
	jmp		genT00 ; return to token main loop
genT01:	
	
	mov		rax, [rbp + 4]	
	mov		rsp, rbp
	pop		rbp
	ret	

; ---------- START COMPILER ----------
; ARGS
;	REX syntax tree
;	RFX file handle
; notes
; expect that the 'section data' header has already been written
; does not close the data section, so the 'section code' header
; must be written elsewhere
; this function finds string constants and extern labels

; ALSO NOTE
findConstants:
	; TODO loop through all chunks and find any externs and strings
	; stick them in the data section when they are found
	push	rbp
	push	rbx
	mov		rbp, rsp
	add		rsp, 10
	
	; [rbp + 1] is the syntax tree
	; [rbp + 2] is the file handle
	; [rbp + 3] is the current node in the tree
	; [rbp + 4] is the tail of the syntax tree
	; [rbp [7, 10]] general purpose
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rex
	
	; get the tail fo the syntax tree for the comparison loop	
	mov		rex, [rbp + 1]
	call	__Chunk_getTail
	mov		[rbp + 4], rax

findC00:
	; while (chunk != NULL)
	cmp		[rbp + 3], 0
	jit		findC01

	; if we found an extern
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 12
	jif		findC02
	; now we know it's an extern
	; the identifier is general[0][0]
	mov		rax, [rax + 4]
	mov		rax, [rax + 0]
	jmp		findC03

findC02:

	; now we want to check the general fields
	; for strings.  If we do find a string, write
	; it to the data section and rewrite the string
	; with the data section identifier
	mov		[rbp + 7], 0 ; this is the current general field
findC0_00:
	lt		[rbp + 7], 4
	jif		findC0_01

	mov		rax, [rbp + 3]
	add		rax, 4
	add		rax, [rbp + 7]
	mov		rax, [rax + 0]
	; rax now contains the TokenList we want to search
	; check if it is null and skip the loop if it is
	cmp		[rax + 0], 0
	jit		findC0_00_01
findC0_00_00:
	; this is the loop where we scan for a string
	; we will scan until TokenList->value == NULL
	cmp		rax, 0
	jit		findC0_00_01
	
	; check if the type of the token inside of the TokenList
	; is a string	
	mov		rbx, [rax + 0]
	mov		rbx, [rbx + 0]
	; rbx now contains the type of the token
	cmp		rbx, 2
	; after the comparison move the word of the token into rbx
	mov		rbx, [rax + 0]
	lea		rbx, [rbx + 1]
	jif		findC0_00_02
	; we now know it is a string, write it to
	; the const memory section
	mov		rex, [rbp + 2]
	mov		rfx, PUT_LET
	mov		rgx, REG_RAX ; TODO UPDTE WITH A COUNTER, THIS IS FOR TEST
	mov		rhx, rbx
	push	4
	ccall	fprintf
findC0_00_02:

	mov		rax, [rax + 1]
	jmp		findC0_00_00
findC0_00_01:
	
	add		[rbp + 7], 1
	jmp		findC0_00
findC0_01:

findC03:

	mov		rax, [rbp + 3]
	mov		[rbp + 3], [rax + 2]
		
	jmp		findC00
findC01:

	mov		rsp, rbp
	pop		rbx
	pop		rbp
	ret

; ARGS
;	REX: file output name
;	RFX: syntax tree
generateBytecode:
	push	rbp
	mov		rbp, rsp
	add		rsp, 4
	
	; [rbp + 1] out file name
	; [rbp + 2] syntax tree
	; [rbp + 3] output file handle
	; [rbp + 4] holds the current node in the tree
	; [rbp + 5] holds the last node in the tree
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx

	; open the file for writing
	mov		rex, [rbp + 1]
	mov		rfx, FS_MODE_W
	push	2
	ccall	fopen
	mov		[rbp + 3], rax

	; write the data section
	mov		rex, [rbp + 3]
	mov		rfx, PUT_SECT
	mov		rgx, SECT_DATA
	ccall	fprintf

	; generate the constant memory section
	; this handles C function externs as well as string literals	
	mov		rex, [rbp + 2]
	mov		rfx, [rbp + 3]
	call	findConstants

	; write a new line
	mov		rex, [rbp + 3]
	mov		rfx, FORMAT_CHAR
	mov		rgx, 10
	ccall	fprintf

	; write the code section
	mov		rex, [rbp + 3]
	mov		rfx, PUT_SECT
	mov		rgx, SECT_CODE
	ccall	fprintf

	; write a new line
	mov		rex, [rbp + 3]
	mov		rfx, FORMAT_CHAR
	mov		rgx, 10
	ccall	fprintf

	; jump to start
	mov		rex, [rbp + 3]
	mov		rfx, PUT_MODE7S
	mov		rgx, INS_JMP
	mov		rhx, LBL_START
	push	4
	ccall	fprintf
	
	; now we're ready to start inserting code

	mov		rsp, rbp
	pop		rbp
	ret


; ARGS
;	REX: FILE CONTENTS
;	RFX: FILE CONTENTS LENGTH
;	RGX: FILE NAME
;	RHX: FILE OUTPUT NAME
start:
	push	rbp
	mov		rbp, rsp
	add		rsp, 6
	
	; STACK MAP
	; FILE CONTENTS				[rbp + 1]
	; FILE CONTENTS LENGTH		[rbp + 2]
	; FILE NAME					[rbp + 3]
	; FILE OUTPUT NAME			[rbp + 4]
	; TOKENS					[rbp + 5]
	; SYNTAX TREE				[rbp + 6]

	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx
	mov		[rbp + 4], rhx
	
	; execute the lexer and generate tokens
	mov		rex, [rbp + 1]
	mov		rfx, [rbp + 2]
	mov		rgx, [rbp + 3]
	mov		rhx, [rbp + 4]
	call	generateTokens
	mov		[rbp + 5], rax

	; execute the parser and generate a syntax tree
	mov		rex, [rbp + 5]
	call	generateTree
	mov		[rbp + 6], rax

	; compile
	mov		rex, [rbp + 4]
	mov		rfx, [rbp + 6]
	call	generateBytecode

	mov		rsp, rbp
	pop		rbp
	exit

