section data
; C functions we will be using
let printf				"printf"
let malloc				"malloc"
let free				"free"	
let strcpy				"strcpy"
let memcpy				"memcpy"
let memset				"memset"
let strcmp				"strcmp"

; ----- constant strings -----
let DEBUG_IO_INOUT		"input name: %s\noutput name: %s\n"

; printf formats
let FORMAT_STRING		"%s\n"
let FORMAT_CHAR			"%c\n"
let FORMAT_NUM			"%d\n"
let FORMAT_HEX			"%x\n"

; file system modes
let FS_MODE_W			"w"
let FS_MODE_R			"r"
let FS_MODE_WB			"wb"
let FS_MODE_RB			"rb"

; token variables
let TOK_DEBUG_OUT		"(type %d : word '%s')\n"
let TOK_EOF				"EOF"

; tokenlist variables
let TOK_LIST_DEBUG_HEAD	"TOKENLIST:\n"
let TOK_KW_FUNC			"func"
let TOK_KW_IF			"if"
let TOK_KW_WHILE		"while"
let TOK_KW_DO			"do"
let TOK_KW_FOR			"for"
let TOK_KW_BREAK		"break"
let TOK_KW_CONTINUE		"continue"
let TOK_KW_RETURN		"return"

; chunk variables
let	CHUNK_DEBUG			"CHUNK:\n\tTYPE: %d\n\tRELATION: %d\n\tADDR: %p\n"

; registers
let REG_RIP				"RIP"
let REG_RSP				"RSP"
let REG_RBP				"RBP"
let REG_RAX				"RAX"
let REG_RBX				"RBX"
let REG_RCX				"RCX"
let REG_RDX				"RDX"
let REG_REX				"REX"
let REG_RFX				"RFX"
let REG_RGX				"RGX"
let REG_RHX				"RGX"
let REG_RIX				"RIX"
let REG_RJX				"RJX"

; instructions
let	INS_NOOP			"NOOP"
let INS_EXIT			"EXIT"
let INS_RET				"RET"
let INS_MOV				"MOV"
let INS_ADD				"ADD"
let INS_SUB				"SUB"	
let INS_MUL				"MUL"
let INS_DIV				"DIV"
let INS_NEG				"NEG"
let INS_OR				"OR"
let INS_AND				"AND"
let INS_XOR				"XOR"
let INS_NOT				"NOT"
let INS_SHL				"SHL"
let INS_SHR				"SHR"
let INS_LT				"LT"
let INS_LE				"LE"
let INS_GT				"GT"
let INS_GE				"GE"
let INS_CMP				"CMP"
let INS_LAND			"LAND"
let INS_LOR				"LOR"
let INS_LNOT			"LNOT"
let INS_PUSH			"PUSH"
let INS_POP				"POP"
let INS_CALL			"CALL"
let INS_CCALL			"CCALL"
let INS_JMP				"JMP"
let INS_JIF				"JIF"
let INS_JIT				"JIT"

let INS_MODE0			"%s\t"
let INS_MODE1			"%s\t%s" 
let INS_MODE2			"%s\t%s, %d"
let INS_MODE3			"%s\t%s, %s"
let INS_MODE4			"%s\t%s, [%s + %d]"
let INS_MODE5			"%s\t[%s + %d], %d"
let INS_MODE6			"%s\t[%s + %d]"
let INS_MODE7			"%s\t%d"
let INS_MODE8			"%s\t[%s + %d], [%s + %d]"

; --------------- START LEXER ---------------
section code
jmp			start

; ARGS
;	REX: string TOKEN_TYPE
;	RFX: string TOKEN_WORD
; RET
;	returns a pointer to a Token
;	[RAX + 0] is TOKEN_TYPE
;	[RAX + 1] is TOKEN_WORD
__Token_new:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 2
	
	; this function creates a new token 
	; a token has two fields
	; [t + 0] = token typeof
	; [t + 1] = token word (sizeof 128) 
	
	mov		[rbp + 1], rex 
	mov		[rbp + 2], rfx
	
	; allocate some space for the token (two chunks)
	mov		rex, 129
	push	1
	ccall	malloc
	
	; the memory for the token is now stored in RAX
	; assign to the fields in memory accordingly
	; move the type in
	mov		[rax + 0], [rbp + 1]
	
	; move the word in
	mov		rex, rax
	add		rex, 1
	mov		rfx, [rbp + 2]
	push	rax
	push	2
	ccall	strcpy
	pop		rax

	mov		rax, rax
	mov		rsp, rbp
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: Token* t
__Token_print:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 1

	mov		[rbp + 1], rex

	; print the token information
	; load the format
	mov		rex, TOK_DEBUG_OUT
	; load the type
	mov		rfx, [rbp + 1]
	mov		rfx, [rfx + 0]
	; load the word
	mov		rgx, [rbp + 1]
	add		rgx, 1
	; now print
	push	3
	ccall	printf

	mov		rsp, rbp
	xor		rax, rax
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: number 
isalpha:
	push	rbp
	mov		rbp, rsp

	ge		rex, 97
	jif		C00
	le		rex, 122
	jif		C00
	mov		rax, 1
	jmp		C01
C00:
	mov		rax, 0
C01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: number
isdigit:
	push	rbp
	mov		rbp, rsp

	ge		rex, 48
	jif		D00
	le		rex, 57
	jif		D00
	mov		rax, 1
	jmp		D01
D00:
	mov		rax, 0
D01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: token array pointer
;	RFX: size of token array
printAllTokens:
	push	rbp
	mov		rbp, rsp
	add		rsp, 3

	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], 0
	
E00:
	lt		[rbp + 3], [rbp + 2]
	jif		E01
	
	; get a pointer to the current token in rax
	mov		rax, [rbp + 1]
	add		rax, [rbp + 3]

	; now print
	mov		rex, [rax + 0]
	call	__Token_print
	
	add		[rbp + 3], 1

	jmp		E00
E01:

	mov		rsp, rbp
	pop		rbp
	ret
	
generateTokens:
	
	push	rbp
	mov		rbp, rsp	
	add		rsp, 2048
	; STACK MAP
	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	; FILE COUNTER				in [rbp + 5]
	; LOCAL CURRENT_CHAR		in [rbp + 6]
	; GENERAL PURPOSE NUMBS		in [rbp + [6, 50]]
	; GENERAL PURPOSE BUFFER	in [rbp + 51]  (of size 512)
	; TOKEN ARRAY POINTER		in [rbp + 562]
	; TOKEN ARRAY				in [rbp + 563] (of size 1024)

	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx
	mov		[rbp + 4], rhx	
	mov		[rbp + 562], 0
	
	; print some debugging information
	mov		rex, DEBUG_IO_INOUT
	mov		rfx, [rbp + 3]
	mov		rgx, [rbp + 4]
	push	3
	ccall	printf	

	; FILE COUNTER		in [rbp + 5]
	mov		[rbp + 5], 0

; while (FILE_COUNTER < FILE_CONTENTS_LENGTH)
L00:
	; FILE_COUNTER < FILE_CONTENTS_LENGTH
	mov		rbx, [rbp + 5]
	lt		rbx, [rbp + 2]
	jif		L01
	
	; load the current character into [rbp + 6]
	mov		rbx, [rbp + 1]			; [rbp + 1] is file contents pointer
	add		rbx, [rbp + 5]			; [rbp + 5] is current index in file contents
	mov		[rbp + 6], [rbx + 0]	; [rbp + 6] now contains the current character

	cmp		[rbp + 6], 32	; skip if is whitespace
	jit		L08
	cmp		[rbp + 6], 9	; skip if is tab
	jit		L08

	; here is the start of the branching process
	; this is where we handle the difference between
	; an identifier, a string, a number, etc
	;	LABEL NOTES
	;		end of branch is L02
	;		
	; (c >= 'a' && c <= 'z');
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L09
	; decided true
	; note that there is a general purpose buffer located at [rbp + 51]
	; we will use that buffer to store the identifier
	mov		[rbp + 51], [rbp + 6]
	; note that we use the general purpose loca [rbp + 7] to store
	; the pointer to the top of the buffer at [rbp + 51]
	; also note we start with 1 because we already wrote the first character above
	mov		[rbp + 7], 1
L05: ; START IDENTIFIER LOOP
	add		[rbp + 5], 1			; increase FILE_COUNTER by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character (dereferenced rax)
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L06

	; we've made sure the character is alpha, now append it to the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]

	add		[rbp + 7], 1 ; increase the buffer pointer

	jmp		L05
L06: ; END IDENTIFIER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], 0
	
	mov		rex, rbp
	add		rex, 51
	mov		rfx, TOK_KW_FUNC		; check 'func'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_01
	mov		[rbp + 9], 101
	jmp		L06_00
L06_01:	
	mov		rfx, TOK_KW_IF			; check 'if'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_02
	mov		[rbp + 9], 102
	jmp		L06_00
L06_02:	
	mov		rfx, TOK_KW_WHILE		; check 'while'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_03
	mov		[rbp + 9], 103
	jmp		L06_00
L06_03:
	mov		rfx, TOK_KW_DO			; check 'while'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_04
	mov		[rbp + 9], 104
	jmp		L06_00
L06_04:
	mov		rfx, TOK_KW_FOR			; check 'for'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_05
	mov		[rbp + 9], 105
	jmp		L06_00
L06_05:
	mov		rfx, TOK_KW_BREAK		; check 'break'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_06
	mov		[rbp + 9], 106
	jmp		L06_00
L06_06:
	mov		rfx, TOK_KW_CONTINUE	; check 'continue'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_07
	mov		[rbp + 9], 107
	jmp		L06_00
L06_07:
	mov		rfx, TOK_KW_RETURN		; check 'continue'
	push	2
	ccall	strcmp
	cmp		rax, 1
	jif		L06_else
	mov		[rbp + 9], 108
	jmp		L06_00
L06_else:
	mov		[rbp + 9], 1
L06_00:
	mov		rex, [rbp + 9]
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02 

L09: ; ELSE IF IS NUMBER
	; go to next if statement if its not a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L07

	; now we know it's a digit, proceed
	mov		[rbp + 51], [rbp + 6]	; move the first digit into the buffer
	
	; now, like before, we use the general purpose local [rbp + 7] to
	; store the pointer to the top of the buffer
	; we set its initial value to 1 because we already pushed the first number
	mov		[rbp + 7], 1
L10: ; START NUMBER LOOP
	; load the next character into [rbp + 6]
	add		[rbp + 5], 1			; increase file pointer by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character

	; now check again if it's a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L11
	
	; now we've made sure the next character is a digit, we can now append it to the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]
	
	; increase the buffer pointer
	add		[rbp + 7], 1	

	; do loop again
	jmp		L10

L11: ; END NUMBER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], 0

	; create a new token
	mov		rex, 3
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax

	; jump to the end of the if statement
	jmp		L02


L07: ; ELSE IF IS OPERATOR
	; now we know that the character is some sort of punctuation or operator
	; we need to set the type of the token accordingly

	; note we store the correct type for the token in the
	; general purpose offset [rbp + 9]
	mov		[rbp + 51], [rbp + 6]
	mov		[rbp + 52], 0 ; initialize the type to TYPE_UNKNOWN
	mov		[rbp + 9], 0
	; switch(character)
	cmp		[rbp + 6], 43 ; case +
	jif		L13
	mov		[rbp + 9], 4
	jmp		L12
L13:
	cmp		[rbp + 6], 45 ; case -
	jif		L14
	mov		[rbp + 9], 5
	jmp		L12
L14:
	cmp		[rbp + 6], 42 ; case *
	jif		L15
	mov		[rbp + 9], 6
	jmp		L12
L15:
	cmp		[rbp + 6], 47 ; case /
	jif		L16
	mov		[rbp + 9], 7
	jmp		L12
L16:
	cmp		[rbp + 6], 37 ; case %
	jif		L17
	mov		[rbp + 9], 8
	jmp		L12
L17:
	cmp		[rbp + 6], 38 ; case &
	jif		L18
	mov		[rbp + 9], 9
	jmp		L12
L18:
	cmp		[rbp + 6], 124 ; case |
	jif		L19
	mov		[rbp + 9], 10
	jmp		L12
L19:
	cmp		[rbp + 6], 94 ; case ^
	jif		L20
	mov		[rbp + 9], 11
	jmp		L12
L20:
	cmp		[rbp + 6], 59 ; case ;
	jif		L21
	mov		[rbp + 9], 12
	jmp		L12
L21:
	cmp		[rbp + 6], 58 ; case :
	jif		L22
	mov		[rbp + 9], 13
	jmp		L12
L22:
	cmp		[rbp + 6], 40 ; case (
	jif		L23
	mov		[rbp + 9], 14
	jmp		L12
L23:
	cmp		[rbp + 6], 41 ; case )
	jif		L24
	mov		[rbp + 9], 15
	jmp		L12
L24:
	cmp		[rbp + 6], 123 ; case {
	jif		L25
	mov		[rbp + 9], 16
	jmp		L12
L25:
	cmp		[rbp + 6], 125 ; case }
	jif		L26
	mov		[rbp + 9], 17
	jmp		L12
L26:
	cmp		[rbp + 6], 91 ; case [
	jif		L27
	mov		[rbp + 9], 18
	jmp		L12
L27:
	cmp		[rbp + 6], 93 ; case ]
	jif		L28
	mov		[rbp + 9], 19
	jmp		L12
L28:
	cmp		[rbp + 6], 60 ; case <
	jif		L29
	; check if <=
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L28_
	; is <=, rewrite word
	mov		[rbp + 52], 61 
	mov		[rbp + 53], 0
	mov		[rbp + 9], 25
	add		[rbp + 5], 1
	jmp		L12
L28_:
	mov		[rbp + 9], 20
	jmp		L12
L29:
	cmp		[rbp + 6], 62 ; case >
	jif		L30
	; check if >=
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L29_
	; is >=, rewrite word
	mov		[rbp + 52], 61
	mov		[rbp + 53], 0
	mov		[rbp + 9], 26
	add		[rbp + 5], 1
	jmp		L12
L29_:
	mov		[rbp + 9], 21
	jmp		L12
L30:
	cmp		[rbp + 6], 61 ; case =
	jif		L31
	; check if ==
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L30_
	; is ==, rewrite word
	mov		[rbp + 52], 61
	mov		[rbp + 53], 0
	mov		[rbp + 9], 27
	add		[rbp + 5], 1
	jmp		L12
L30_:
	mov		[rbp + 9], 22
	jmp		L12
L31:
	cmp		[rbp + 6], 44 ; case ,
	jif		L32
	mov		[rbp + 9], 23
	jmp		L12
L32:
	cmp		[rbp + 6], 46 ; case .
	jif		L33
	mov		[rbp + 9], 24
	jmp		L12
L33:
	cmp		[rbp + 6], 10 ; case \n
	jif		L34
	; because it's a newline we don't actually want the
	; word of the token to be '\n' (for debugging reasons)
	; here we just overwrite the word
	mov		[rbp + 51], 0
	mov		[rbp + 9], 25
	jmp		L12
L34:
L12:
	mov		rex, [rbp + 9]
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02

L02: ; LEX LOOP INCREMENT FILE_COUNTER
	; the token we created is in [rbp + 8]
	; append it to the token array
	mov		rax, rbp
	add		rax, 563
	add		rax, [rbp + 562]
	mov		[rax + 0], [rbp + 8]
	; now increase the token pointer
	add		[rbp + 562], 1

	mov		rex, [rbp + 8]

L08: ; JUMP HERE TO SKIP
	add		[rbp + 5], 1
	jmp		L00
L01: ; END LEX LOOP
	; add a null token
	mov		rex, 0
	mov		rfx, TOK_EOF
	call	__Token_new
	mov		[rbp + 8], rax
	mov		rax, rbp
	add		rax, 563
	add		rax, [rbp + 562]
	mov		[rax + 0], [rbp + 8]
	add		[rbp + 562], 1

	; return a pointer to the tokens
	mov		rax, rbp
	add		rax, 563
	
	mov		rsp, rbp
	pop		rbp	
	ret

; --------------- START PARSER ---------------

; ARGS
;	REX token
__TokenList_new:
	push	rbp
	mov		rbp, rsp
	add		rsp, 1

	mov		[rbp + 1], rex
	
	; allocate memory for the list
	mov		rex, 2
	push	1
	ccall	malloc

	mov		[rax + 0], [rbp + 1]
	; also write a null pointer for the `next` field because
	; there is no next token yet
	mov		[rax + 1], 0

	mov		rax, rax

	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: TokenList
__TokenList_getTail:
	push	rbp
	mov		rbp, rsp
	add		rsp, 2

	; [rbp + 1] is TokenList
	mov		[rbp + 1], rex

getTail00:
	; while (t->next != NULL)
	mov		rax, [rbp + 1]
	cmp		[rax + 1], 0
	jit		getTail01

	; t = t->next;
	mov		rax, [rbp + 1]
	mov		[rbp + 1], [rax + 1]

	jmp		getTail00
getTail01:
	mov		rax, [rbp + 1]
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: TokenList head
;	RFX: TokenList to append
__TokenList_append:
	push	rbp
	push	rbx
	mov		rbp, rsp
	add		rsp, 2
	
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	
	; if head->value is NULL, then just set
	; head to the new token, don't append
	mov		rax, [rbp + 1]
	cmp		[rax + 0], 0
	jif		append01
append00:
	; head->next remains NULL
	; head->value becomes to_append->value
	mov		rax, [rbp + 1]
	mov		rbx, [rbp + 2]
	mov		[rax + 0], [rbx + 0]
	mov		[rax + 1], 0
	mov		[rbx + 1], 0
	jmp		append02
append01:
	; set to_append->next to null
	mov		rax, [rbp + 2]
	mov		[rax + 1], 0

	; get the tail of the TokenList to append to
	mov		rex, [rbp + 1]
	call	__TokenList_getTail
	; now set TokenList->tail->next to the TokenList we just created
	mov		[rax + 1], [rbp + 2]
append02:
	mov		rsp, rbp
	pop		rbx
	pop		rbp
	ret

; ARGS
;	REX: TokenList
__TokenList_print:
	push	rbp
	mov		rbp, rsp
	add		rsp, 3
	
	; [rbp + 1] TokenList
	; [rbp + 2] TokenList->tail
	mov		[rbp + 1], rex
	
	; printf("TOKENLIST:\n");
	mov		rex, TOK_LIST_DEBUG_HEAD
	push	1
	ccall	printf

	mov		[rbp + 3], [rbp + 1]
print00:
	; while (t != NULL)
	cmp		[rbp + 3], 0
	jit		print01

	; if there is no token being pointed to
	; then continue
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 0
	jit		print02

	mov		rex, [rbp + 3]
	mov		rex, [rex + 0]
	call	__Token_print

	; t = t->next
print02:
	mov		rax, [rbp + 3]
	mov		[rbp + 3], [rax + 1]

	jmp		print00
print01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: type
;	RFX: relation
;	RGX: pointer to last
__Chunk_new:
	push	rbp
	push	rbx
	mov		rbp, rsp
	add		rsp, 5

	; [rbp + 1] type
	; [rbp + 2] relation
	; [rbp + 3] pointer to last
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx

	; allocate some memory for a chunk
	mov		rex, 8
	push	1
	ccall	malloc
	mov		[rbp + 4], rax ; [rbp + 4] chunk

	mov		rax, [rbp + 4]
	mov		[rax + 0], [rbp + 1]	; set chunk->type
	mov		[rax + 1], [rbp + 2]	; set chunk->relation
	mov		[rax + 2], 0			; set chunk->next	
	mov		[rax + 3], [rbp + 3]	; set chubk->last

	; initialize general lists to NULL
	; [rbp + 5] is loop counter
	mov		[rbp + 5], 0
Chunknew00:
	lt		[rbp + 5], 4
	jif		Chunknew01
	
	; create a new general list
	mov		rex, 0
	call	__TokenList_new

	; move it into the proper field
	mov		rbx, [rbp + 4]
	add		rbx, 4
	add		rbx, [rbp + 5]
	mov		[rbx + 0], rax

	add		[rbp + 5], 1
	jmp		Chunknew00
Chunknew01:	
	mov		rax, [rbp + 4]
	mov		rsp, rbp
	pop		rbx
	pop		rbp
	ret

; ARGS
;	REX: chunk
__Chunk_getTail:
	push	rbp
	mov		rbp, rsp
	add		rsp, 1
	
	; this is the current chunk we're at
	mov		[rbp + 1], rex	
Chunk_getTail00:
	; check if chunk->next is NULL
	mov		rax, [rbp + 1]
	cmp		[rax + 2], 0
	jit		Chunk_getTail01
	
	mov		rax, [rbp + 1]
	mov		[rbp + 1], [rax + 2]

	jmp		Chunk_getTail00
Chunk_getTail01:
	; return the tail
	mov		rax, [rbp + 1]
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: chunk
;	RFX: chunk to append
__Chunk_append:
	push	rbp
	mov		rbp, rsp
	add		rsp, 2
	
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx

	; get the tail of the chunk we want to append to
	mov		rex, [rbp + 1]
	call	__Chunk_getTail
	
	; set tail->next to chunk_to_append
	mov		[rax + 2], [rbp + 2]

	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: chunk
__Chunk_print:
	push	rbp
	mov		rbp, rsp
	add		rsp, 1
	
	; pointer to the current chunk	
	mov		[rbp + 1], rex
Chunk_print00:
	cmp		[rbp + 1], 0
	jit		Chunk_print01

	mov		rex, CHUNK_DEBUG
	mov		rfx, [rbp + 1]
	mov		rfx, [rfx + 0]
	mov		rgx, [rbp + 1]
	mov		rgx, [rgx + 1]
	mov		rhx, [rbp + 1]
	push	4
	ccall	printf

	mov		rex, [rbp + 1]
	mov		rex, [rex + 4]
	call	__TokenList_print

	mov		rax, [rbp + 1]
	mov		[rbp + 1], [rax + 2]
	jmp		Chunk_print00
Chunk_print01:
	
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: chunk
;	RFX: index
;	RGX: token_list
__Chunk_setGeneralField:
	push	rbp
	mov		rbp, rsp
	sub		rsp,

	mov		[rbp + 1], rex ; chunk
	mov		[rbp + 2], rfx ; index
	mov		[rbp + 3], rgx ; token_list

	; find the location we want to write to
	mov		rax, [rbp + 1]
	add		rax, 4
	add		rax, [rbp + 2]

	; now write
	mov		[rax + 0], [rbp + 3]

	mov		rsp, rbp
	pop		rbp
	ret	


; ARGS
;	REX: array of tokens
generateTree:
	push	rbp
	mov		rbp, rsp
	add		rsp, 10 ; 7 general purpose

	; [rbp + 1]		array of tokens
	; [rbp + 2]		index of current token
	; [rbp + 3]		holds the current token
	; [rbp + 4]		head chunk for syntax tree
	; [rbp + 5]		current syntax tree depth
	; [rbp + 6]		the chunk we will append to the main sytax tree
	; [rbp + 7]		general0
	; [rbp + 8]		general1
	; [rbp + 9]		general2
	; [rbp + 10]	general3

	mov		[rbp + 1], rex
	mov		[rbp + 2], 0
	mov		[rbp + 3], 0
	
	; create a head chunk for the syntax tree
	; move it into [rbp + 4]
	mov		rex, 1
	mov		rfx, 0
	call	__Chunk_new
	mov		[rbp + 4], rax

	; the current tree depth, stored in [rbp + 5]
	mov		[rbp + 5], 0

genT00: ; while tokens[i].type != TYPE_UNKNOWN
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	cmp		[rax + 0], 0
	jit		genT01

	; store current token
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0] 

	; the new chunk we want to append will be stored
	; in [rbp + 6]

	; switch (token->type)
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 25
	jit		genT04				; skip if newline
	
	; --- CHECK FUNC TOKEN ---
	mov		rax, [rbp + 3]
	cmp		[rax + 0], 101
	jif		genT03	
		
	; --- IS FUNC ---
	; SYNTAX FOR A FUNCTION IMPLEMENTATION:
	; func name(argnamee, argname2, ...) { ... }

	; create a chunk to hold the function
	mov		rex, 3
	mov		rfx, [rbp + 5]
	call	__Chunk_new
	mov		[rbp + 6], rax
	
	; function name TokenList 
	mov		rex, 0
	call	__TokenList_new
	mov		[rbp + 7], rax

	; function return type TokenList
	mov		rex, 0
	call	__TokenList_new
	mov		[rbp + 8], rax

	; increment the token pointer to the name of the function
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	; store the TokenList containing the name in chunk->general[0]
	mov		rex, [rbp + 3]
	call	__TokenList_new
	mov		rex, [rbp + 7]
	mov		rfx, rax
	call	__TokenList_append
	mov		rex, [rbp + 4]
	mov		rfx, 0
	mov		rgx, [rbp + 7]
	call	__Chunk_setGeneralField

	; increment the token pointer to the first argument
	; note that we increment by two to skip over the '('
	add		[rbp + 2], 1
	mov		rax, [rbp + 1]
	add		rax, [rbp + 2]
	mov		[rbp + 3], [rax + 0]

	jmp		genT02
	; --- ELSE: STILL HAVEN'T MATCHED A TOKEN ---
genT03: ; else
	mov		rex, 0
	mov		rfx, [rbp + 5]
	call	__Chunk_new
	mov		[rbp + 6], rax
	jmp		genT02
genT02: ; done, append to head chunk
	mov		rex, [rbp + 4]
	mov		rfx, [rbp + 6]
	call	__Chunk_append
genT04: ; skip, don't append
	add		[rbp + 2], 1
	jmp		genT00 ; return to token main loop
genT01:	
	mov		rex, [rbp + 4]
	call	__Chunk_print
	
	mov		rax, [rbp + 4]	
	mov		rsp, rbp
	pop		rbp
	ret	

; ARGS
;	REX: FILE CONTENTS
;	RFX: FILE CONTENTS LENGTH
;	RGX: FILE NAME
;	RHX: FILE OUTPUT NAME
start:
	push	rbp
	mov		rbp, rsp
	add		rsp, 6
	
	; STACK MAP
	; FILE CONTENTS				[rbp + 1]
	; FILE CONTENTS LENGTH		[rbp + 2]
	; FILE NAME					[rbp + 3]
	; FILE OUTPUT NAME			[rbp + 4]
	; TOKENS					[rbp + 5]
	; SYNTAX TREE				[rbp + 6]

	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx
	mov		[rbp + 4], rhx
	
	; execute the lexer and generate tokens
	mov		rex, [rbp + 1]
	mov		rfx, [rbp + 2]
	mov		rgx, [rbp + 3]
	mov		rhx, [rbp + 4]
	call	generateTokens
	mov		[rbp + 5], rax

	; execute the parser and generate a syntax tree
	mov		rex, [rbp + 5]
	call	generateTree
	mov		[rbp + 6], rax

	mov		rsp, rbp
	pop		rbp
	exit

