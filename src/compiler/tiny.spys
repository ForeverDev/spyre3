section data
; C functions we will be using
let printf				"printf"	; void	printf(format, ...);
let malloc				"malloc"	; ptr	malloc(size);
let free				"free"		; ptr	free(ptr);
let strcpy				"strcpy"	; void	strcpy(dest, src);

; ----- constant strings -----
let DEBUG_IO_INOUT		"input name: %s\noutput name: %s\n"

; printf formats
let FORMAT_SIMPLESTRING	"%s\n"
let FORMAT_SIMPLECHAR	"%c\n"
let FORMAT_SIMPLENUM	"%d\n"

; file system modes
let FS_MODE_W			"w"
let FS_MODE_R			"r"
let FS_MODE_WB			"wb"
let FS_MODE_RB			"rb"

let TOK_DEBUG_OUT		"(type %d : word '%s')\n"

; registers
let REG_RIP				"RIP"
let REG_RSP				"RSP"
let REG_RBP				"RBP"
let REG_RAX				"RAX"
let REG_RBX				"RBX"
let REG_RCX				"RCX"
let REG_RDX				"RDX"
let REG_REX				"REX"
let REG_RFX				"RFX"
let REG_RGX				"RGX"
let REG_RHX				"RGX"
let REG_RIX				"RIX"
let REG_RJX				"RJX"

; instructions
let	INS_NOOP			"NOOP"
let INS_EXIT			"EXIT"
let INS_RET				"RET"
let INS_MOV				"MOV"
let INS_ADD				"ADD"
let INS_SUB				"SUB"	
let INS_MUL				"MUL"
let INS_DIV				"DIV"
let INS_NEG				"NEG"
let INS_OR				"OR"
let INS_AND				"AND"
let INS_XOR				"XOR"
let INS_NOT				"NOT"
let INS_SHL				"SHL"
let INS_SHR				"SHR"
let INS_LT				"LT"
let INS_LE				"LE"
let INS_GT				"GT"
let INS_GE				"GE"
let INS_CMP				"CMP"
let INS_LAND			"LAND"
let INS_LOR				"LOR"
let INS_LNOT			"LNOT"
let INS_PUSH			"PUSH"
let INS_POP				"POP"
let INS_CALL			"CALL"
let INS_CCALL			"CCALL"
let INS_JMP				"JMP"
let INS_JIF				"JIF"
let INS_JIT				"JIT"

let INS_MODE0			"%s\t"
let INS_MODE1			"%s\t%s" 
let INS_MODE2			"%s\t%s, %d"
let INS_MODE3			"%s\t%s, %s"
let INS_MODE4			"%s\t%s, [%s + %d]"
let INS_MODE5			"%s\t[%s + %d], %d"
let INS_MODE6			"%s\t[%s + %d]"

; CODE STARTS HERE
; some quick notes about the style of the code:
;	- a method of a 'class' has two underscores (__) before the name
;	- all 'class' methods take 'this' in as the first parameter
;	- for organizational purposes, arguments passed to a function are
;	  loaded onto the stack by the callee	
section code
jmp			start

; ARGS
;	REX: string TOKEN_TYPE
;	RFX: string TOKEN_WORD
; RET
;	returns a pointer to a Token
;	[RAX + 0] is TOKEN_TYPE
;	[RAX + 1] is TOKEN_WORD
__Token_new:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 2
	
	; this function creates a new token 
	; a token has two fields
	; [t + 0] = token typeof
	; [t + 1] = token word (sizeof 128) 
	
	mov		[rbp + 1], rex 
	mov		[rbp + 2], rfx
	
	; allocate some space for the token (two chunks)
	mov		rex, 129
	push	1
	ccall	malloc
	
	; the memory for the token is now stored in RAX
	; assign to the fields in memory accordingly
	; move the type in
	mov		[rax + 0], [rbp + 1]
	
	; move the word in
	mov		rex, rax
	add		rex, 1
	mov		rfx, [rbp + 2]
	push	rax
	push	2
	ccall	strcpy
	pop		rax

	mov		rax, rax
	mov		rsp, rbp
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: Token* t
__Token_print:
	push	rbx
	push	rbp
	mov		rbp, rsp
	add		rsp, 1

	mov		[rbp + 1], rex

	; print the token information
	; load the format
	mov		rex, TOK_DEBUG_OUT
	; load the type
	mov		rfx, [rbp + 1]
	mov		rfx, [rfx + 0]
	; load the word
	mov		rgx, [rbp + 1]
	add		rgx, 1
	; now print
	push	3
	ccall	printf

	mov		rsp, rbp
	xor		rax, rax
	pop		rbp
	pop		rbx
	ret

; ARGS
;	REX: number 
isalpha:
	push	rbp
	mov		rbp, rsp

	ge		rex, 97
	jif		C00
	le		rex, 122
	jif		C00
	mov		rax, 1
	jmp		C01
C00:
	mov		rax, 0
C01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: number
isdigit:
	push	rbp
	mov		rbp, rsp

	ge		rex, 48
	jif		D00
	le		rex, 57
	jif		D00
	mov		rax, 1
	jmp		D01
D00:
	mov		rax, 0
D01:
	mov		rsp, rbp
	pop		rbp
	ret

; ARGS
;	REX: token array pointer
;	RFX: size of token array
printAllTokens:
	push	rbp
	mov		rbp, rsp
	add		rsp, 3

	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], 0
	
E00:
	lt		[rbp + 3], [rbp + 2]
	jif		E01
	
	; get a pointer to the current token in rax
	mov		rax, [rbp + 1]
	add		rax, [rbp + 3]

	; now print
	mov		rex, [rax + 0]
	call	__Token_print
	
	add		[rbp + 3], 1

	jmp		E00
E01:

	mov		rsp, rbp
	pop		rbp
	ret
	
; ARGUMENTS
; REX FILE CONTENTS
; RFX FILE CONTENTS LENGTH
; RGX FILE NAME
; RHX FILE OUTPUT NAME
start:
	
	mov		rbp, rsp	
	add		rsp, 2048
	; STACK MAP
	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	; FILE COUNTER				in [rbp + 5]
	; LOCAL CURRENT_CHAR		in [rbp + 6]
	; GENERAL PURPOSE NUMBS		in [rbp + [6, 50]]
	; GENERAL PURPOSE BUFFER	in [rbp + 51]  (of size 512)
	; TOKEN ARRAY POINTER		in [rbp + 562]
	; TOKEN ARRAY				in [rbp + 563] (of size 1024)

	; FILE CONTENTS				in [rbp + 1]
	; FILE CONTENTS LENGTH		in [rbp + 2]
	; FILE NAME					in [rbp + 3]
	; FILE OUTPUT NAME			in [rbp + 4]
	mov		[rbp + 1], rex
	mov		[rbp + 2], rfx
	mov		[rbp + 3], rgx
	mov		[rbp + 4], rhx	
	mov		[rbp + 562], 0
	
	; print some debugging information
	mov		rex, DEBUG_IO_INOUT
	mov		rfx, [rbp + 3]
	mov		rgx, [rbp + 4]
	push	3
	ccall	printf	

	; FILE COUNTER		in [rbp + 5]
	mov		[rbp + 5], 0

; while (FILE_COUNTER < FILE_CONTENTS_LENGTH)
L00:
	; FILE_COUNTER < FILE_CONTENTS_LENGTH
	mov		rbx, [rbp + 5]
	lt		rbx, [rbp + 2]
	jif		L01
	
	; load the current character into [rbp + 6]
	mov		rbx, [rbp + 1]			; [rbp + 1] is file contents pointer
	add		rbx, [rbp + 5]			; [rbp + 5] is current index in file contents
	mov		[rbp + 6], [rbx + 0]	; [rbp + 6] now contains the current character

	cmp		[rbp + 6], 32	; skip if is whitespace
	jit		L08
	cmp		[rbp + 6], 10	; skip if is newline
	jit		L08
	cmp		[rbp + 6], 9	; skip if is tab
	jit		L08

	; here is the start of the branching process
	; this is where we handle the difference between
	; an identifier, a string, a number, etc
	;	LABEL NOTES
	;		end of branch is L02
	;		
	; (c >= 'a' && c <= 'z');
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L09
	; decided true
	; note that there is a general purpose buffer located at [rbp + 51]
	; we will use that buffer to store the identifier
	mov		[rbp + 51], [rbp + 6]
	; note that we use the general purpose loca [rbp + 7] to store
	; the pointer to the top of the buffer at [rbp + 51]
	; also note we start with 1 because we already wrote the first character above
	mov		[rbp + 7], 1
L05: ; START IDENTIFIER LOOP
	add		[rbp + 5], 1			; increase FILE_COUNTER by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character (dereferenced rax)
	mov		rex, [rbp + 6]
	call	isalpha
	cmp		rax, 1
	jif		L06

	; we've made sure the character is alpha, now append it to the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]

	add		[rbp + 7], 1 ; increase the buffer pointer

	jmp		L05
L06: ; END IDENTIFIER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], 0

	mov		rex, 1
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02 

L09: ; ELSE IF IS NUMBER
	; go to next if statement if its not a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L07

	; now we know it's a digit, proceed
	mov		[rbp + 51], [rbp + 6]	; move the first digit into the buffer
	
	; now, like before, we use the general purpose local [rbp + 7] to
	; store the pointer to the top of the buffer
	; we set its initial value to 1 because we already pushed the first number
	mov		[rbp + 7], 1
L10: ; START NUMBER LOOP
	; load the next character into [rbp + 6]
	add		[rbp + 5], 1			; increase file pointer by one
	mov		rax, [rbp + 1]			; load file pointer into rax
	add		rax, [rbp + 5]			; load current character pointer into rax
	mov		[rbp + 6], [rax + 0]	; [rbp + 6] now contains current character

	; now check again if it's a digit
	mov		rex, [rbp + 6]
	call	isdigit
	cmp		rax, 1
	jif		L11
	
	; now we've made sure the next character is a digit, we can now append it to the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], [rbp + 6]
	
	; increase the buffer pointer
	add		[rbp + 7], 1	

	; do loop again
	jmp		L10

L11: ; END NUMBER LOOP
	; decrease FILE_COUNTER by 1
	sub		[rbp + 5], 1
	; null terminate the buffer
	mov		rax, rbp
	add		rax, 51
	add		rax, [rbp + 7]
	mov		[rax + 0], 0

	; create a new token
	mov		rex, 3
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax

	; jump to the end of the if statement
	jmp		L02


L07: ; ELSE IF IS OPERATOR
	; now we know that the character is some sort of punctuation or operator
	; we need to set the type of the token accordingly

	; note we store the correct type for the token in the
	; general purpose offset [rbp + 9]
	mov		[rbp + 51], [rbp + 6]
	mov		[rbp + 52], 0 ; initialize the type to TYPE_UNKNOWN
	mov		[rbp + 9], 0
	; switch(character)
	cmp		[rbp + 6], 43 ; case +
	jif		L13
	mov		[rbp + 9], 4
	jmp		L12
L13:
	cmp		[rbp + 6], 45 ; case -
	jif		L14
	mov		[rbp + 9], 5
	jmp		L12
L14:
	cmp		[rbp + 6], 42 ; case *
	jif		L15
	mov		[rbp + 9], 6
	jmp		L12
L15:
	cmp		[rbp + 6], 47 ; case /
	jif		L16
	mov		[rbp + 9], 7
	jmp		L12
L16:
	cmp		[rbp + 6], 37 ; case %
	jif		L17
	mov		[rbp + 9], 8
	jmp		L12
L17:
	cmp		[rbp + 6], 38 ; case &
	jif		L18
	mov		[rbp + 9], 9
	jmp		L12
L18:
	cmp		[rbp + 6], 124 ; case |
	jif		L19
	mov		[rbp + 9], 10
	jmp		L12
L19:
	cmp		[rbp + 6], 94 ; case ^
	jif		L20
	mov		[rbp + 9], 11
	jmp		L12
L20:
	cmp		[rbp + 6], 59 ; case ;
	jif		L21
	mov		[rbp + 9], 12
	jmp		L12
L21:
	cmp		[rbp + 6], 58 ; case :
	jif		L22
	mov		[rbp + 9], 13
	jmp		L12
L22:
	cmp		[rbp + 6], 40 ; case (
	jif		L23
	mov		[rbp + 9], 14
	jmp		L12
L23:
	cmp		[rbp + 6], 41 ; case )
	jif		L24
	mov		[rbp + 9], 15
	jmp		L12
L24:
	cmp		[rbp + 6], 123 ; case {
	jif		L25
	mov		[rbp + 9], 16
	jmp		L12
L25:
	cmp		[rbp + 6], 125 ; case }
	jif		L26
	mov		[rbp + 9], 17
	jmp		L12
L26:
	cmp		[rbp + 6], 91 ; case [
	jif		L27
	mov		[rbp + 9], 18
	jmp		L12
L27:
	cmp		[rbp + 6], 93 ; case ]
	jif		L28
	mov		[rbp + 9], 19
	jmp		L12
L28:
	cmp		[rbp + 6], 60 ; case <
	jif		L29
	; check if <=
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L28_
	; is <=, rewrite word
	mov		[rbp + 52], 61 
	mov		[rbp + 53], 0
	mov		[rbp + 9], 25
	add		[rbp + 5], 1
	jmp		L12
L28_:
	mov		[rbp + 9], 20
	jmp		L12
L29:
	cmp		[rbp + 6], 62 ; case >
	jif		L30
	; check if >=
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L29_
	; is >=, rewrite word
	mov		[rbp + 52], 61
	mov		[rbp + 53], 0
	mov		[rbp + 9], 26
	add		[rbp + 5], 1
	jmp		L12
L29_:
	mov		[rbp + 9], 21
	jmp		L12
L30:
	cmp		[rbp + 6], 61 ; case =
	jif		L31
	; check if ==
	mov		rax, [rbp + 1]
	add		rax, [rbp + 5]
	add		rax, 1
	cmp		[rax + 0], 61
	jif		L30_
	; is ==, rewrite word
	mov		[rbp + 52], 61
	mov		[rbp + 53], 0
	mov		[rbp + 9], 27
	add		[rbp + 5], 1
	jmp		L12
L30_:
	mov		[rbp + 9], 22
	jmp		L12
L31:
	cmp		[rbp + 6], 44 ; case ,
	jif		L32
	mov		[rbp + 9], 23
	jmp		L12
L32:
	cmp		[rbp + 6], 46 ; case .
	jif		L33
	mov		[rbp + 9], 24
	jmp		L12
L33:
L12:
	mov		rex, [rbp + 9]
	mov		rfx, rbp
	add		rfx, 51
	call	__Token_new
	mov		[rbp + 8], rax
	jmp		L02

L02: ; LEX LOOP INCREMENT FILE_COUNTER

	; the token we created is in [rbp + 8]
	; append it to the token array
	mov		rax, rbp
	add		rax, 563
	add		rax, [rbp + 562]
	mov		[rax + 0], [rbp + 8]
	; now increase the token pointer
	add		[rbp + 562], 1

L08: ; JUMP HERE TO SKIP
	add		[rbp + 5], 1
	jmp		L00
L01: ; END LEX LOOP
	
	; print tokens for debugging
	mov		rex, rbp
	add		rex, 563
	mov		rfx, [rbp + 562]		
	call	printAllTokens

	exit
